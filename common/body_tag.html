<!-- <script src = "https://unpkg.com/markerjs">// modules are defined as an array


// [ module function, map of requires ]

// map of requires is short require name -> numeric require

// anything defined in a previous bundle is accessed via the
// orig method which is the require for previous bundles
parcelRequire = (function (modules, cache, entry, globalName) {
  // Save the require from previous bundle to this closure if any
  var previousRequire = typeof parcelRequire === 'function' && parcelRequire;
  var nodeRequire = typeof require === 'function' && require;

  function newRequire(name, jumped) {
    if (!cache[name]) {
      if (!modules[name]) {
        // if we cannot find the module within our internal map or
        // cache jump to the current global require ie. the last bundle
        // that was added to the page.
        var currentRequire = typeof parcelRequire === 'function' && parcelRequire;
        if (!jumped && currentRequire) {
          return currentRequire(name, true);
        }
                  
        // If there are other bundles on this page the require from the
        // previous one is saved to 'previousRequire'. Repeat this as
        // many times as there are bundles until the module is found or
        // we exhaust the require chain.
        if (previousRequire) {
          return previousRequire(name, true);
        }

        // Try the node require function if it exists.
        if (nodeRequire && typeof name === 'string') {
          return nodeRequire(name);
        }

        var err = new Error('Cannot find module \'' + name + '\'');
        err.code = 'MODULE_NOT_FOUND';
        throw err;
      }

      localRequire.resolve = resolve;
      localRequire.cache = {};

      var module = cache[name] = new newRequire.Module(name);

      modules[name][0].call(module.exports, localRequire, module, module.exports, this);
    }

    return cache[name].exports;

    function localRequire(x){
      return newRequire(localRequire.resolve(x));
    }

    function resolve(x){
      return modules[name][1][x] || x;
    }
  }

  function Module(moduleName) {
    this.id = moduleName;
    this.bundle = newRequire;
    this.exports = {};
  }

  newRequire.isParcelRequire = true;
  newRequire.Module = Module;
  newRequire.modules = modules;
  newRequire.cache = cache;
  newRequire.parent = previousRequire;
  newRequire.register = function (id, exports) {
    modules[id] = [function (require, module) {
      module.exports = exports;
    }, {}];
  };

  var error;
  for (var i = 0; i < entry.length; i++) {
    try {
      newRequire(entry[i]);
    } catch (e) {
      // Save first error but execute all entries
      if (!error) {
        error = e;
      }
    }
  }

  if (entry.length) {
    // Expose entry point to Node, AMD or browser globals
    // Based on https://github.com/ForbesLindesay/umd/blob/master/template.js
    var mainExports = newRequire(entry[entry.length - 1]);

    // CommonJS
    if (typeof exports === "object" && typeof module !== "undefined") {
      module.exports = mainExports;

    // RequireJS
    } else if (typeof define === "function" && define.amd) {
     define(function () {
       return mainExports;
     });

    // <script>
    } else if (globalName) {
      this[globalName] = mainExports;
    }
  }

  // Override the current require with this new one
  parcelRequire = newRequire;

  if (error) {
    // throw error from earlier, _after updating parcelRequire_
    throw error;
  }

  return newRequire;
})({"js/replaceNthMatch.js":[function(require,module,exports) {
/**
 * Replaces the nth occurance of a string
 * 
 * @param {String} string The string your searching inside of
 * @param {String/RegExp} regex The substring to search for
 * @param {String} n Either a string or callback that returns a string
 * @param {Number} replace The nth occurance to replace (base 1, to replace index 2 pass in 2)
 * 
 * @returns String with replacements
 */
module.exports = function (string, regex, n, replace) {
  var i = 0;
  string = string.replace(regex, function (match) {
    return ++i === n ? replace : match;
  });
  return string;
};
},{}],"app.js":[function(require,module,exports) {
function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var replaceNthMatch = require('./js/replaceNthMatch');


$('body').on('click', '.d-editor-preview img:not(.emoji)', function () {
  // Don't click on oneboxes
  

  if ($(this).closest('.onebox').length) return false;
  var $target = $(this);
  var isMouseDown = false;
  var $canvas;
  var ctx;
  var sketch = {
    brush: {
      strokeStyle: '#f00',
      brush: 'pen',
      lineWidth: 4
    },
    history: [] // Show modal on click
    // setTimeout(0) to allow elements paint onto DOM

  };
  console.log('clicked');
  window.labofoz.component.imageAnnotator.showModal('labofoz-image-annotator-modal');
  var mark = new markerjs.MarkerArea(document.querySelector('.d-editor-preview img:not(.emoji)'));
    mark.show(function(dataUrl) {
      var res = document.querySelector('.d-editor-preview img:not(.emoji)');
      res.src = dataUrl;
    }); 
  window.labofoz.component.imageAnnotator.showModal('labofoz-image-annotator-modal');
  setTimeout(function () {
    /**
     * Setup the canvas
     */
    $('.labofoz-image-annotator-canvas').each(function () {
      this.width = $target.width();
      this.height = $target.height();
      $canvas = this;
      ctx = this.getContext('2d');
      ctx.drawImage($target[0], 0, 0, this.width, this.height);
    })
    /**
     * Add current brush to history on drag
     */
    .mousemove(function (ev) {
      addHistory(_objectSpread({
        action: 'mousemove',
        x: ev.clientX - this.offsetLeft,
        y: ev.clientY - this.offsetTop
      }, sketch.brush));
    })
    /**
     * Start a new path
     */
    .mousedown(function (ev) {
      isMouseDown = true;
      addHistory(_objectSpread({
        action: 'mousedown',
        x: ev.clientX - this.offsetLeft,
        y: ev.clientY - this.offsetTop
      }, sketch.brush));
    });
    $('body').mouseup(function () {
      return isMouseDown = false;
    }); 
    /**
     * Handle save
     * - Loops through previewer to determine the nth position of this image in the set of $('.d-editor-preview img:not(.emoji)')
     * - Selects string starting with a similar title in the editor textarea, in the form of ![]() and <img src="">
     */

    $('#labofoz-image-annotator-save').click(function (ev) {
      console.log("me: " + $target[0] + "  tareget 2" + $target[1]);
      
      $('.modal-close .close').trigger('click');
      $target[0].src = $canvas.toDataURL(); // Find the index of the edited image
      
      $('.d-editor-preview img:not(.emoji)').each(function (n) {
        if ($target[0] !== this) return; // Find that string in the editor

        var $editor = $('#reply-control textarea.d-editor-input').first();
        // var newText = replaceNthMatch($editor.val(), /(!\[.*?\]\()(.+?)(\))/g, n + 1, '**REPLACED**');
        var newText = replaceNthMatch($editor.val(), /(!\[.*?\]\()(.+?)(\))/g, n + 1, '**Modifited Image**');
        $editor.val(newText);
      });
      return ev.preventDefault();
    });
  });
  /**
   * Called whent he user clicks down on the canvas
   * - Stores the action in sketch.history
   */

  function addHistory(history) {
    if (!isMouseDown) return;
    var numPoints = sketch.history.length;
    sketch.history.push(history);

    if (sketch.history.length > 1 && history.action === 'mousemove') {
      ctx.beginPath();
      ctx.lineWidth = history.lineWidth;
      ctx.strokeStyle = history.strokeStyle;
      ctx.moveTo(sketch.history[numPoints - 1].x, sketch.history[numPoints - 1].y);
      ctx.lineTo(history.x, history.y);
      ctx.closePath();
      ctx.stroke();
    }
  }
});
 },{"./js/replaceNthMatch":"js/replaceNthMatch.js"}]},{},["app.js"], null)

</script> -->